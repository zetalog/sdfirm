# Duowen Vaisra
config CPU_VAISRA
	bool
	select CPU_64G
	select CPU_S
	select CPU_SV39
	select CPU_SV48
	select CPU_PMP
	select CPU_COUNTERS
	select CPU_WMO
	select ARCH_IS_ATOMIC_UNFAIR
	select ARCH_HAS_HPM_EVENT if HPM

# SiFive E51
config CPU_E51
	bool
	select CPU_64I
	select CPU_M
	select CPU_A
	select CPU_C
	select CPU_COUNTERS
	select CPU_WMO

# SiFive U54
config CPU_U54
	bool
	select CPU_64G
	select CPU_S
	select CPU_C
	select CPU_SV39
	select CPU_PMP
	select CPU_COUNTERS
	select CPU_WMO

# THead Xuantie C910
config CPU_C910
	bool
	select CPU_64G
	select CPU_S
	select CPU_C
	select CPU_V
	select CPU_SV39
	select CPU_PMP
	select CPU_WMO

# RI5CY
config CPU_RI5CY
	bool
	select CPU_32I
	select CPU_M
	select CPU_F
	select CPU_C
	select CPU_N
	select CPU_PMP
	select CPU_VIRQ
	select CPU_WMO
	select ARCH_HAS_PMU
	select ARCH_HAS_RI5CY_FIRQ

config CPU_CV32E40P
	bool
	select CPU_RI5CY
	select ARCH_HAS_RI5CY_FIRQ_EXT

config CPU_CVA6
	bool
	select CPU_64G
	select CPU_C
	select CPU_S
	select CPU_SV39
	select CPU_WMO

# ZERO RISCY
config CPU_0RISCY
	bool
	select CPU_32I
	select CPU_32E
	select CPU_M
	select CPU_C
	select CPU_WMO

# SPIKE
config CPU_SPIKE32
	bool
	select CPU_32G
	select CPU_S
	select CPU_C
	select CPU_SV32
	select CPU_PMP
	select CPU_WMO

config CPU_SPIKE64
	bool
	select CPU_64G
	select CPU_S
	select CPU_C
	select CPU_SV39
	select CPU_SV48
	select CPU_PMP
	select CPU_WMO

# VIRT
config CPU_VIRT32
	bool
	select CPU_32G
	select CPU_S
	select CPU_C
	select CPU_SV32
	select CPU_PMP
	select CPU_COUNTERS
	select CPU_WMO

config CPU_VIRT64
	bool
	select CPU_64G
	select CPU_S
	select CPU_C
	select CPU_SV39
	select CPU_PMP
	select CPU_COUNTERS
	select CPU_WMO

config CPU_32G
	bool
	select CPU_32I
	select CPU_ZIFENCEI
	select CPU_ZICSR
	select CPU_M
	select CPU_A
	select CPU_F
	select CPU_D

config CPU_64G
	bool
	select CPU_64I
	select CPU_ZIFENCEI
	select CPU_ZICSR
	select CPU_M
	select CPU_A
	select CPU_F
	select CPU_D

config CPU_WMO
	bool

config CPU_32I
	bool

config CPU_64I
	bool

config CPU_32E
	bool

config CPU_128I
	bool

choice
	prompt "Base ISA"
	default RISCV_32I
	help
	  This selects the base ISA that this kernel will target and must match
	  the target platform.

config RISCV_32I
	bool "RV32I"
	depends CPU_32I
	select 32BIT

config RISCV_64I
	bool "RV64I"
	depends CPU_64I
	select 64BIT

config RISCV_32E
	bool "RV32E"
	depends CPU_32E
	select 32BIT

config RISCV_128I
	bool "RV128I"
	depends CPU_128I
	select 128BIT

endchoice

menu "ISA extensions"

config CPU_S
	bool

config CPU_ZIFENCEI
	bool

config CPU_ZICSR
	bool

config CPU_M
	bool

config CPU_A
	bool
	select ARCH_HAS_SMP

config CPU_F
	bool
	select ARCH_HAS_FP

config CPU_D
	bool
	select CPU_F

config CPU_Q
	bool
	select CPU_D

config CPU_C
	bool

config CPU_ZTSO
	bool

config CPU_COUNTERS
	bool

config CPU_L
	bool

config CPU_B
	bool

config CPU_J
	bool

config CPU_T
	bool

config CPU_P
	bool

config CPU_V
	bool

config CPU_N
	bool

config CPU_ZAM
	bool

config CPU_H
	bool

config CPU_PMA
	bool

config CPU_PMP
	bool

config CPU_SV32
	bool
	depends 32BIT && RISCV_EXIT_S
	select ARCH_HAS_MMU

config CPU_SV39
	bool
	depends 64BIT && RISCV_EXIT_S
	select ARCH_HAS_MMU
	select ARCH_HAS_MMU_HUGE

config CPU_SV48
	bool
	depends 64BIT && RISCV_EXIT_S
	select ARCH_HAS_MMU
	select ARCH_HAS_MMU_HUGE

config CPU_VIRQ
	bool

config RISCV_S
	bool
	depends CPU_S
	default y

config RISCV_M
	bool "Multiplication and division (M) support"
	depends CPU_M
	default y

config RISCV_A
	bool "Atomic instructions (A) support"
	depends CPU_A
	default y

config RISCV_F
	bool "Single-precision floating-point (F) support"
	depends CPU_F

config RISCV_D
	bool "Double-precision floating-point (D) support"
	depends CPU_D
	select RISCV_F

config RISCV_Q
	bool "Quad-precision floating-point (Q) support"
	depends CPU_Q
	select RISCV_D

config RISCV_L
	bool "Decimal floating-point (L) support"
	depends CPU_L

config RISCV_C
	bool "Compressed instructions (C) support"
	depends CPU_C
	default y

config RISCV_ZTSO
	bool "Total store ordering (TSO) support"
	depends CPU_ZTSO
	default y

config RISCV_COUNTERS
	bool "Performance counters and timer (counters) support"
	depends CPU_COUNTERS
	select MATH_DIV64
	default y

config RISCV_B
	bool "Bit manipulation (B) support"
	depends CPU_B
	default y

config RISCV_J
	bool "Dynamically translated languages (J) support"
	depends CPU_J

config RISCV_T
	bool "Transactional memory (T) support"
	depends CPU_T
	default y

config RISCV_P
	bool "Packed-SIMD instructions (P) support"
	depends CPU_P

config RISCV_V
	bool "Vector operations (V) support"
	depends CPU_V

config RISCV_N
	bool "User-level interrupts (N) support"
	depends CPU_N && RISCV_U
	default y

config RISCV_ZAM
	bool "Misaligned atomics (Zam) support"
	depends CPU_ZAM
	default y

config RISCV_PMA
	bool "Physical address attributes (PMA) support"
	depends CPU_PMA
	default y

config RISCV_PMP
	bool "Physical address protection (PMP) support"
	depends CPU_PMP
	select BIT_FLS32 if 32BIT
	select BIT_FLS64 if 64BIT
	default y

config RISCV_H
	bool "Hypervisor extension support"
	depends CPU_H

menuconfig RISCV_SV
	bool "Supervisor virtual addresing"
	depends ARCH_HAS_MMU
	select RISCV_S
	select ARCH_HAS_MMU_BARRIER if !RISCV_SV_ZIFENCEI

if RISCV_SV

choice
	prompt "Virtual memory bit"

config RISCV_SV32
	bool "Sv32"
	depends CPU_SV32
	select ARCH_HAS_MMU_4K
	select ARCH_HAS_MMU_3L

config RISCV_SV39
	bool "Sv39"
	depends CPU_SV39
	select ARCH_HAS_MMU_4K
	select ARCH_HAS_MMU_3L

config RISCV_SV48
	bool "Sv48"
	depends CPU_SV48
	select ARCH_HAS_MMU_4K
	select ARCH_HAS_MMU_4L

endchoice

config RISCV_SV_ZIFENCEI
	bool "Enable instrution fetch barrier"
	depends CPU_ZIFENCEI

endif

config RISCV_VIRQ
	bool "Vectorized interrupt support"
	depends CPU_VIRQ

endmenu

menu "CPU architecture options"

choice
	prompt "Memory consistency model"

config RISCV_WMO
	bool "Weak memory ordering (RVWMO)"
	depends CPU_WMO

config RISCV_TSO
	bool "Total store ordering (RVTSO)"
	depends CPU_ZTSO
	select RISCV_ZTSO

endchoice

if RISCV_A

choice
	prompt "Type of atomic counter"

config RISCV_ATOMIC_COUNT_32
	bool "signed 32-bit"
	select ARCH_HAS_BITS_PER_UNIT_32
	depends !SMP

config RISCV_ATOMIC_COUNT_64
	bool "signed 64-bit"
	select ARCH_HAS_BITS_PER_UNIT_64

endchoice

config ARCH_IS_ATOMIC_UNFAIR
	bool

choice
	prompt "Type of SMP spinlock"
	default RISCV_SPINLOCK_RAW

config RISCV_SPINLOCK_RAW
	bool "Raw spinlock"
	depends !ARCH_IS_ATOMIC_UNFAIR
	help
	  May suffer from lock fairness, and dead locks due to cache
	  contension.

config RISCV_SPINLOCK_TICKET
	bool "Ticket spinlock"
	help
	  Always fair, however may suffer from SMP cache performance.

config RISCV_SPINLOCK_GENERIC
	bool "Queued spinlock"
	select ARCH_HAS_QSPINLOCK if SMP
	help
	  Alway fair, however, due to no awoswap 16-bit implementation,
	  consumes more memory for each spinlock_t.

endchoice

endif

endmenu

menu "Compiler options"

config CC_NO_RELAX
	bool "Disable link relaxation"

# We must be able to map all physical memory into the kernel, but the compiler
# is still a bit more efficient when generating code if it's setup in a manner
# such that it can only map 2GiB of memory.
choice
	prompt "Program code model (-mcmodel)"
	default CMODEL_MEDLOW if 32BIT
	default CMODEL_MEDANY if 64BIT

config CMODEL_MEDLOW
	bool "medium low code model"

config CMODEL_MEDANY
	bool "medium any code model"

endchoice

choice
	prompt "CPU Tuning"
	default TUNE_GENERIC

config TUNE_GENERIC
	bool "generic"

endchoice

choice
	prompt "Maximum Physical Memory"
	default MAXPHYSMEM_2GB if 32BIT
	default MAXPHYSMEM_2GB if 64BIT && CMODEL_MEDLOW
	default MAXPHYSMEM_128GB if 64BIT && CMODEL_MEDANY

config MAXPHYSMEM_2GB
	bool "2GiB"

config MAXPHYSMEM_128GB
	depends on 64BIT && CMODEL_MEDANY
	bool "128GiB"

endchoice

endmenu

config SYS_ENTR_M
	bool

config SYS_ENTR_S
	bool

config SYS_EXIT_M
	bool

config SYS_EXIT_S
	bool

config SYS_EXIT_U
	bool

choice
	prompt "Privileged software stack"
	default RISCV_AEE

config RISCV_AEE
	bool "AEE (Application)"
	help
	  Application execution environment.

config RISCV_SEE
	bool "SEE (Supervisor)"
	depends RISCV_S

config RISCV_HEE
	bool "HEE (Hypervisor)"
	depends RISCV_H

endchoice

choice
	prompt "Entry priviledge level"

# Disabled for the firmware system
#config RISCV_ENTR_U
#	bool "U-Mode"

config RISCV_ENTR_S
	bool "S-Mode"
	depends SYS_ENTR_S

config RISCV_ENTR_M
	bool "M-Mode"
	depends SYS_ENTR_M

endchoice

choice
	prompt "Exit priviledge level"

# Disabled for the firmware system
config RISCV_EXIT_U
	bool "U-Mode"
	depends SYS_EXIT_U
	select RISCV_N if (CPU_N && !SYS_NOIRQ)

config RISCV_EXIT_S
	bool "S-Mode"
	depends SYS_EXIT_S

config RISCV_EXIT_M
	bool "M-Mode"
	depends SYS_EXIT_M

endchoice

config SYS_LOADER
	bool
	depends BOOTLOADER
	default y if RISCV_ENTR_M

config SYS_KERNEL
	bool
	depends !BOOTLOADER
	default y if RISCV_EXIT_S && (RISCV_SEE || RISCV_HEE)

config SYS_MONITOR
	bool
	depends !BOOTLOADER
	default y if RISCV_ENTR_M && (RISCV_SEE || RISCV_HEE)

config ARCH_HAS_BOOT0
	bool

config ARCH_HAS_BOOT1
	bool

config ARCH_HAS_BOOT2
	bool

menu "System peripherals"

config RISCV_IRQ_VERBOSE
	bool "Enable IRQ handler verbosity"
	depends SIMULATION && EXPERIMENTAL
	help
	  This is useful for IRQ testing.

config ARCH_HAS_HTIF
	bool

config HTIF
	bool "Host Target Interface (HTIF) support"
	depends ARCH_HAS_HTIF
	help
	  The interface can be found in spike (RISCV ISA simulator).

config ARCH_HAS_CLINT
	bool

menuconfig CLINT
	bool "Core Local Interruptor (CLINT) support"
	depends ARCH_HAS_CLINT
	select ARCH_HAS_SBI_IPI
	select ARCH_HAS_SBI_TIMER
	select MATH_DIV64

if CLINT

config CLINT_XCHG_LLSC
	bool "Use LL/SC style xchg"
	help
	  By default, CLINT driver uses amoswap to do IPI atomicity.
	  However, this doesn't work for all architectures. Enabling this
	  option allows the driver to switch to use LL/SC based xchg.
	  If unsure, say 'N'.

config CLINT_FORCE_FAST_TIMEOUT
	bool "Force Clint timer to use very shot timeout"
	help
	  On simulation environments, any timeout value may be too long
	  to be simulated. Select this option allows the driver to force
	  a small enough value for simulation.
	  If unsure, say 'N'.

endif

config ARCH_HAS_PLIC
	bool

config ARCH_HAS_PLIC_EOI_EARLY
	bool

menuconfig PLIC
	bool "Platform level interrupt controller (PLIC) support"
	depends ARCH_HAS_PLIC
	select ARCH_HAS_IRQC_ACK if !PLIC_COMPLETION

if PLIC

config PLIC_COMPLETION
	bool "Enable internal IRQ completion"
	depends ARCH_HAS_PLIC_EOI_EARLY
	help
	  By default, PLIC driver allows hardware drivers to invoke IRQ
	  completion as EOI indication. However, for realtime reasons,
	  PLIC driver may complete the IRQ in the IRQ context.
	  If unsure, say 'N'.

choice
	prompt "Internal completion timing"
	default PLIC_COMPLETION_EXIT

config PLIC_COMPLETION_ENTRY
	bool "IRQ entry"

config PLIC_COMPLETION_EXIT
	bool "IRQ exit"

endchoice

config PLIC_MASK_PRIORITY
	bool "Enable priority based IRQ masking"
	depends PLIC_COMPLETION
	select ARCH_HAS_IRQC_MASK
	help
	  By default, PLIC uses ENABLER based IRQ masking. This option
	  allows to use PRIORITYR based IRQ masking, at the cost that the
	  hardware drivers can only use the lowest priority - 1.
	  If unsure, say 'N'.

endif

config ARCH_HAS_HPM_EVENT
	bool

menuconfig HPM
	bool "Hardware performance monotor support"
	select ARCH_HAS_PMU

if HPM

config HPM_EVENT
	bool "Enable hpmevent register support"
	depends ARCH_HAS_HPM_EVENT

endif

menuconfig RI5CY_PC
	bool "RI5CY performance counter support"
	depends CPU_RI5CY
	select ARCH_HAS_PMU

config ARCH_HAS_RI5CY_FIRQ
	bool

config ARCH_HAS_RI5CY_FIRQ_EXT
	bool
	select ARCH_HAS_RI5CY_FIRQ

menuconfig RI5CY_FIRQ
	bool "RI5CY fast interrupt support"
	depends ARCH_HAS_RI5CY_FIRQ

menuconfig RI5CY_FIRQ_EXT
	bool "RI5CY extended fast interrupt support"
	depends RI5CY_FIRQ && ARCH_HAS_RI5CY_FIRQ_EXT

menuconfig VAISRA_TBOX
	bool "Vaisra tube and trickbox support"
	depends CPU_VAISRA
	help
	  A simple IRQ triggering source that can be seen on ARM based CPU
	  benches. Due to its simplicity and ACE compatibility, it can be
	  easily ported to the RISC-V based CPU benches like VAISRA to work
	  as an external IRQ source.
	  The hardware also includes a tube register that allows to end the
	  simulation.

menuconfig VAISRA_PMA
	bool "Vaisra physical memory attributes support"
	depends CPU_VAISRA
	help
	  Vaisra SoC PMA driver.

if VAISRA_PMA

menu "Default normal memory attributes"

config VAISRA_PMA_NON_ALLOCATE
	bool "Enable normal memory write-back non-allocate"
	depends !VAISRA_PMA_TRANSIENT

config VAISRA_PMA_WRITE_THROUGH
	bool "Enable normal memory write-through"

config VAISRA_PMA_TRANSIENT
	bool "Enable normal memory traisient"

endmenu

menu "Default device attributes"

config VAISRA_PMA_GATHERING
	bool "Enable device memory gathering"
	select VAISRA_PMA_RE_ORDERING

config VAISRA_PMA_RE_ORDERING
	bool "Enable device memory re-ordering"
	select VAISRA_PMA_EARLY_WRITE_ACK

config VAISRA_PMA_EARLY_WRITE_ACK
	bool "Enable device memory early write acknowledgement"

endmenu

endif

menuconfig VAISRA_RAS
	bool "Vaisra reliability availability serviceability (RAS) support"
	depends !SYS_NOIRQ || SBI

endmenu
