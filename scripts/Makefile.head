# Figure out what we need to build from the various variables
# ===========================================================================

# When an object is listed to be built compiled-in and modular,
# only build the compiled-in version

# Libraries are always collected in one lib file.
# Filter out objects already built-in

lib-y := $(filter-out $(obj-y), $(lib-y))


# Handle objects in subdirs
# ---------------------------------------------------------------------------
# o if we encounter foo/ in $(obj-y), replace it by foo/built-in.lib
#   and add the directory to the list of dirs to descend into: $(subdir-y)

__subdir-y	:= $(patsubst %/,%,$(filter %/, $(obj-y)))
subdir-y	+= $(__subdir-y)
obj-y		:= $(patsubst %/, %/built-in.lib, $(obj-y))

# Subdirectories we need to descend into

subdir-ym	:= $(subdir-y)

# if $(foo-objs) exists, foo.o is a composite object 
multi-used-y := $(sort $(foreach m,$(obj-y), $(if $(strip $($(m:.o=-objs)) $($(m:.o=-y))), $(m))))
multi-used   := $(multi-used-y)

# Build list of the parts of our composite objects, our composite
# objects depend on those (obviously)
multi-objs-y := $(foreach m, $(multi-used-y), $($(m:.o=-objs)) $($(m:.o=-y)))
multi-objs   := $(multi-objs-y)

# $(subdir-obj-y) is the list of objects in $(obj-y) which do not live
# in the local directory
subdir-obj-y := $(foreach o,$(obj-y),$(if $(filter-out $(o),$(notdir $(o))),$(o)))

# $(obj-dirs) is a list of directories that contain object files
obj-dirs := $(dir $(multi-objs) $(subdir-obj-y))

# Replace multi-part objects by their individual parts, look at local dir only
real-objs-y := $(foreach m, $(filter-out $(subdir-obj-y), $(obj-y)), $(if $(strip $($(m:.o=-objs)) $($(m:.o=-y))),$($(m:.o=-objs)) $($(m:.o=-y)),$(m))) $(extra-y)

# Add subdir path

extra-y		:= $(addprefix $(obj)/,$(extra-y))
always		:= $(addprefix $(obj)/,$(always))
targets		:= $(addprefix $(obj)/,$(targets))
obj-y		:= $(addprefix $(obj)/,$(obj-y))
lib-y		:= $(addprefix $(obj)/,$(lib-y))
subdir-obj-y	:= $(addprefix $(obj)/,$(subdir-obj-y))
real-objs-y	:= $(addprefix $(obj)/,$(real-objs-y))
multi-used-y	:= $(addprefix $(obj)/,$(multi-used-y))
multi-objs-y	:= $(addprefix $(obj)/,$(multi-objs-y))
subdir-ym	:= $(addprefix $(obj)/,$(subdir-ym))
obj-dirs	:= $(addprefix $(obj)/,$(obj-dirs))

# These flags are needed for modversions and compiling, so we define them here
# already
# Note: It's possible that one object gets potentially linked into more
#       than one module. In that case KBUILD_MODNAME will be set to foo_bar,
#       where foo and bar are the name of the modules.
name-fix = $(subst $(comma),_,$(subst -,_,$1))

_c_flags       = $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$(basetarget).o)
_a_flags       = $(AFLAGS) $(EXTRA_AFLAGS) $(AFLAGS_$(basetarget).o)
_cpp_flags     = $(CPPFLAGS) $(EXTRA_CPPFLAGS) $(CPPFLAGS_$(@F))

# If building the kernel in a separate objtree expand all occurrences
# of -Idir to -I$(srctree)/dir except for absolute paths (starting with '/').

ifeq ($(KBUILD_SRC),)
__c_flags	= $(_c_flags)
__a_flags	= $(_a_flags)
__cpp_flags	= $(_cpp_flags)
else

# -I$(obj) locates generated .h files
# $(call addtree,-I$(obj)) locates .h files in srctree, from generated .c files
#   and locates generated .h files
# FIXME: Replace both with specific CFLAGS* statements in the makefiles
__c_flags	= $(call addtree,-I$(obj)) $(call flags,_c_flags)
__a_flags	=                          $(call flags,_a_flags)
__cpp_flags	=                          $(call flags,_cpp_flags)
endif

ifeq ($(COMPILER), sdcc)
include scripts/Kbuild.sdcc.flags
endif
ifeq ($(COMPILER), gcc)
include scripts/Kbuild.gcc.flags
endif
ifeq ($(COMPILER),)
$(error No compiler is defined.)
endif

# Finds dt-bindings
DTC_INCLUDE    := include include/std $(srctree)/include $(srctree)/include/std

dtc_cpp_flags  = -Wp,-MMD,$(depfile).pre.tmp -nostdinc		\
		 $(addprefix -I,$(DTC_INCLUDE))			\
		 -undef -D__DTS__				\
		 -undef -D__ASSEMBLY__ -undef -DLINKER_SCRIPT

# Finds the multi-part object the current object will be linked into
modname-multi = $(sort $(foreach m,$(multi-used),\
		$(if $(filter $(subst $(obj)/,,$*.o), $($(m:.o=-objs)) $($(m:.o=-y))),$(m:.o=))))

# Shipped files
# ===========================================================================

quiet_cmd_shipped = SHIPPED $@
cmd_shipped = cat $< > $@

$(obj)/%:: $(src)/%_shipped
	$(call cmd,shipped)

# Commands useful for building a boot image
# ===========================================================================
# 
#	Use as following:
#
#	target: source(s) FORCE
#		$(if_changed,ld/objcopy/gzip)
#
#	and add target to extra-y so that we know we have to
#	read in the saved command line

# Linking
# ---------------------------------------------------------------------------

quiet_cmd_ld = LD      $@
cmd_ld = $(LD) $(LDFLAGS) $(EXTRA_LDFLAGS) $(LDFLAGS_$(@F)) \
	       $(filter-out FORCE,$^) -o $@ 

# Objcopy
# ---------------------------------------------------------------------------

quiet_cmd_objcopy = OBJCOPY $@
ifeq ($(COMPILER), sdcc)
include scripts/Kbuild.sdcc.objcopy
endif
ifeq ($(COMPILER), gcc)
include scripts/Kbuild.gcc.objcopy
endif
ifeq ($(COMPILER),)
$(error No compiler is defined.)
endif

# Gzip
# ---------------------------------------------------------------------------

quiet_cmd_gzip = GZIP    $@
cmd_gzip = gzip -f -9 < $< > $@


# MKSUNXIBOOT
# ---------------------------------------------------------------------------
#
quiet_cmd_mksunxiboot = MKSUNXIBOOT $@
      cmd_mksunxiboot = $(MKSUNXIBOOT) $(MKSUNXIBOOTFLAGS) $(MKSUNXIBOOTFLAGS_$(@F)) $< $@


# SREC2VHX
# ---------------------------------------------------------------------------
#
quiet_cmd_srec2vhx = SREC2VHX $@
      cmd_srec2vhx = $(SREC2VHX) $(SREC2VHXFLAGS) $(SREC2VHXFLAGS_$(@F)) $< $@


# BINC2VHX
# ---------------------------------------------------------------------------
#
quiet_cmd_bin2vhx = BIN2VHX $@
      cmd_bin2vhx = $(BIN2VHX) $< $@ $(BIN2VHXFLAGS) $(BIN2VHXFLAGS_$(@F))

# DTC
# ---------------------------------------------------------------------------
DTC ?= dtc

# Disable noisy checks by default
ifeq ($(findstring 1,$(KBUILD_EXTRA_WARN)),)
DTC_FLAGS +=
endif

ifneq ($(findstring 2,$(KBUILD_EXTRA_WARN)),)
DTC_FLAGS += -Wnode_name_chars_strict \
	-Wproperty_name_chars_strict \
	-Wno-unit_address_vs_reg \
	-Wno-unit_address_format \
	-Wno-avoid_unnecessary_addr_size \
	-Wno-alias_paths \
	-Wno-graph_child_address \
	-Wno-simple_bus_reg \
	-Wno-unique_unit_address \
	-Wno-pci_device_reg
endif

DTC_FLAGS += $(DTC_FLAGS_$(basetarget))

# Generate an assembly file to wrap the output of the device tree compiler
quiet_cmd_dt_S_dtb= DTB     $@
cmd_dt_S_dtb=						\
{							\
	echo '\#include <asm-generic/sdfirm.lds.h>'; 	\
	echo '.section .fdt,"a"';			\
	echo '.global fdt_bin';				\
	echo 'fdt_bin:';				\
	echo '.incbin "$<" ';				\
} > $@

$(obj)/%.dtb.S: $(obj)/%.dtb FORCE
	$(call if_changed,dt_S_dtb)

quiet_cmd_dtc = DTC     $@
cmd_dtc = mkdir -p $(dir ${dtc-tmp}) ; \
	$(HOSTCC) -E $(dtc_cpp_flags) -x assembler-with-cpp -o $(dtc-tmp) $< ; \
	cp -f $(dtc-tmp) $(basename $@).dtc; \
	$(DTC) -O $(patsubst .%,%,$(suffix $@)) -o $@ -b 0 \
		$(addprefix -i,$(dir $<) $(DTC_INCLUDE)) $(DTC_FLAGS) \
		-d $(depfile).dtc.tmp $(dtc-tmp) ; \
	cat $(depfile).pre.tmp $(depfile).dtc.tmp > $(depfile)

$(obj)/%.dtb: $(src)/%.dts FORCE
	$(call if_changed_dep,dtc)

dtc-tmp = $(subst $(comma),_,$(dot-target).dts.tmp)

